1. Для всех таблиц выводим их название, имена ограничений, типы ограничений, имена столбцов, на которые эти ограничения наложены, позиции,
а также имена ограничений родительской таблицы, на которые ссылаются вторичные ключи дочерних таблиц.
2. Для каждой из таблиц выбираем только столбцы с ограничением первичного ключа и записываем их в представленном виде.
3. То же самое проделываем со столбцами с ограничемием типа уникальный.
4. Для таблиц, имеющих ограничение типа внешнего ключа, выводим их название , название родительской таблицы, столбец внешнего ключа и позицию. Информацию получаем путем соединения таблицы из пункта 1 с самой собой.
5. Для каждой дочерней таблицы и каждой ее родительской записываем столбцы с ограничением внешнего ключа через запятую. Затем из этого подзапроса выбираем имя дочерней таблицы, а имя родительской записываем вместе со столбцами с ограничением внешнего ключа, как показано в примере.
6. Далее соединяем таблицы из USER_TABLES со всеми полученными в предыдущих шагах таблицами по имени таблицы (используем внешнее соединение, чтобы вывести информацию о всех таблицах схемы, даже о тех, которые не имеют предложенных ограничений). Отсутствующие ограничения заменяем - с помощью функции NVL. Конечный результат сортируется по имени таблицы.
---------------------------------------------------------------------------
1. Вводим строку, содержащую четное количество цифр, разделенных запятой.
2. Разделяем полученую строку на кости, путем вырезания подстроки из двух соседних цифр, разделенных запятой. Здесь используется иерархический подзапрос и связь уровней при помощи псевдостолбца LEVEL.
3. Для каждой кости получаем еще и обратную кость, а также номер строки.
4. Составляем последовательности костей последняя цифра предыдущей кости должна равнять первой цифре последующей. Однако здесь может возникнуть ситуация когда одна и та же кость используется дважды в прямом и перевернутом виде. Для отсечения неверно построенных последовательностей запоминаем еще и номера строк костей, которые совпадают у одинаковых костей.
5. Чтобы отсечь неверно построенные последовательности строим всевозможные варианты номеров костей, в которых эти номера не повторяются.
6. Далее отбираем только те последовательности, у которых последовательность номеров строк находится в диапазоне значений, вычисленных в пункте 5. А также находим максимальную длину среди тех последовательностей, которые построены верно.
---------------------------------------------------------------------------
1. Вводим строку чисел с разделителями.
2. Из исходной строки при помощи регулярных выражений извлекаем все числа.
3. Записываем полученные числа в обратном порядке при помощи функции LISTAGG.
4. Объединяем исходную и перевернутую строку при помощи декартова произведения.
---------------------------------------------------------------------------1. Вводим исходное число.
2. Из числа извлекаем все цифры и составляем из них всевозможные уникальные числа, по длине равных длине исходного числа.
3. Далее берем по символу строки по уровням, вычитаем по модулю и суммируем
4. Выбираем только те числа, сумма абсолютных разностей у которых максимальна.
---------------------------------------------------------------------------
1. Получаем исходную таблицу, содержащую пары дочерних и родительских вершин.
2. Исходную таблицу объединяем с такой же таблицей, но с поменяными местами дочерних и родительских элементов, а также с таблицей, которая на месте родителей содержит дочерние элементы и не содержит родительских.
3. Далее для всех вершин, кроме листовых, находим вершины, с которыми они имеют связь.
4. Затем при помощи функции LISTAGG выводим уникальные последовательности вершин, которые образуют связанное множество. Причем вершины сортируются по возрастанию.
---------------------------------------------------------------------------
WITH TAB AS  (
    SELECT  '2,1,2,6,4,2,2,5,5,5' STR
    FROM DUAL
),
TAB2 AS (
    SELECT SUBSTR(','||STR,4*LEVEL-2,3) KOSTI
    FROM TAB
    CONNECT BY LEVEL<=(REGEXP_COUNT(STR,',')+1)/2
),
TAB3 AS (
    SELECT KOSTI, ROWNUM RN
    FROM TAB2
    UNION  
    SELECT SUBSTR(KOSTI,3,1)||','||SUBSTR(KOSTI,1,1), ROWNUM 
    FROM TAB2
),
TAB4 AS (
    SELECT SYS_CONNECT_BY_PATH(KOSTI,'  ') STR, SYS_CONNECT_BY_PATH(RN,'-') RN1
    FROM TAB3
    CONNECT BY NOCYCLE PRIOR RN<>RN AND SUBSTR(KOSTI,1,1)=SUBSTR(PRIOR KOSTI,3,1)
),
TAB5 AS (
    SELECT DISTINCT SYS_CONNECT_BY_PATH(RN,'-') NNUM
    FROM (SELECT DISTINCT RN
          FROM TAB3) 
    CONNECT BY NOCYCLE PRIOR RN<>RN
)
SELECT STR RESULT
FROM TAB4
WHERE RN1 IN (SELECT NNUM
              FROM TAB5)
AND LENGTH(RN1)=(SELECT MAX(LENGTH(RN1))
                 FROM TAB4
                 WHERE RN1 IN (SELECT NNUM
                               FROM TAB5));
---------------------------------------------------------------------------
WITH STR AS(
    SELECT '0|0|1|2|1|2|10|22|34|15|0|105|66|73' STR 
    FROM DUAL
)
SELECT STR "Строка", LISTAGG(REVSTR,'|') WITHIN GROUP (ORDER BY LVL DESC) "Строка наоборот"
FROM(SELECT REGEXP_SUBSTR(STR,'[^|]+',1,LEVEL) REVSTR,LEVEL LVL
     FROM STR
     CONNECT BY LEVEL<=REGEXP_COUNT(STR,'|')
    )REVERSE CROSS JOIN STR;